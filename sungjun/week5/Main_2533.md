## 백준 2533 - 사회망 서비스(SNS)

***

### 구현 목표
친구 관계 그래프에서 어떤 새로운 아이디어를 먼저 받아들인 사람을 얼리아답터라고 한다. 얼리아답터가 아닌 사람은 자신의 모든 친구가 얼리아답터일 때 새로운 아이디어를 받아들이게 된다.

친구 관계 트리가 주어졌을 때, 모든 개인이 새로운 아이디어를 받아들이기 위해 필요한 최소한의 얼리아답터의 수를 구해야 한다.

***

### 풀이 방식
이 문제는 크게 생각하면 루트 노드가 얼리아답터일 때와 그렇지 않을 때의 두 가지 경우의 수로 볼 수 있다. 따라서 dp를 사용하면 비교적 간단히 풀이가 가능하다.

1. 친구 관계는 양방향이기 때문에 데이터를 입력받을 때 양방향 노드로 추가해 준다.
2. 부모 노드가 얼리아답터가 아니라면 자식 노드는 모두 얼리아답터여야 한다.
3. 부모 노드가 얼리아답터라면 자식 노드는 얼리아답터일 수도, 아닐 수도 있다.
4. 루트 노드가 얼리아답터일 때와 그렇지 않았을 때를 각각 계산하여 둘 중 더 작은 값이 정답이 된다.

``` Java
private static void dp(int cur, int parent) {
    dp[cur][0] = 0; 	// 부모 노드가 얼리아답터가 아닐 때
    dp[cur][1] = 1;		// 부모 노드가 얼리아답터일 때
    
    for (int next : Node.get(cur)) {
        if(next != parent) {
            dp(next, cur);
            // 부모 노드가 얼리아답터가 아니라면 자식 노드는 모두 얼리아답터여야 한다
            dp[cur][0] += dp[next][1];	
            // 부모 노드가 얼리아답터라면 자식 노드는 얼리아답터일 수도, 아닐 수도 있다
            dp[cur][1] += Math.min(dp[next][0], dp[next][1]);	
        }
    }
}
```

***

### 주의점

풀이를 알고 나면 간단한 문제였지만 dp를 어떤 식으로 구현해야 할지 감을 잡기가 힘들었다. 다양한 경우에 대해 좀 더 폭넓은 사고를 하는 연습이 필요할거 같다.