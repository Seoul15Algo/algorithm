## 백준 1987 - 알파벳

***

### 구현 목표
주어진 세로 R, 가로 C칸의 보드 안에서 같은 알파벳이 적힌 칸을 두 번 이상 지나지 않고 좌측 상단에서부터 최대 몇 칸을 이동할 수 있는지 구해야 한다.

***

### 풀이 방식
1. 방문한 곳의 알파벳 저장
2. 최대 이동 거리 증가
3. 현재 위치로부터 사방탐색 진행
4. 다음 칸의 알파벳이 아직 방문하지 않은 알파벳이라면 이동하여 이어서 탐색 진행
5. 사방이 모두 이미 방문한 알파벳이라면 마지막으로 저장한 방문 알파벳 제거하고 이전 위치로 회귀
6. 회귀한 위치로부터 사방탐색 이어서 다시 진행

```
private static void search(int i, int j, int max) {
		// 출발 칸의 알파벳에 해당하는 방문 체크 배열 인덱스 증가
		visited[board[i][j]-64]++;
		max++;
		
		for (int k = 0; k < 4; k++) {
			// 방문하지 않은 알파벳이라면
			if(visited[board[i+rv[k]][j+cv[k]]-64] == 0) {
				search(i+rv[k], j+cv[k], max);	// 이동하여 이어서 탐색 진행
			}
		}
		
		// depth 올라오면서 마지막으로 저장한 방문 알파벳 제거
		visited[board[i][j]-64]--;
		if(maxValue < max) maxValue = max;	// 최대값 비교
	}
```

***

### 주의점
일반적인 dfs와 다르게 방문한 인덱스를 체크하는 방문 체크 배열이 필요없음!!

알파벳 개수 + 보드 외곽(보드의 인덱스 범위를 벗어난 경우)를 나타내는 '@' 에 해당하는 길이 27의 방문 체크 배열을 활용하여 실행시간을 대폭 감소시켰다