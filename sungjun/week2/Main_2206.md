## 백준 2206 - 벽 부수고 이동하기

***

### 구현 목표
주어진 N x M의 2차원 배열 형태의 맵에서 좌측 상단부터 우측 하단까지 최단 경로로 이동했을 때 이동거리를 구해야 한다. 단, 막혀있는 벽을 부수고 지나갈 수 있는 기회가 한 번 주어진다.

***

### 풀이 방식
1. 이동하면서 방문한 칸에 대해 방문 처리
2. 벽을 만나면 벽을 부술 기회가 남아있는지 체크
3. 기회가 남아있다면, 해당 벽을 방문한 적이 있는지(이미 부수고 간 적이 있는지) 체크
4. 벽을 부술 기회도 남아있고, 해당 벽을 방문한 적도 없다면 부수고 해당 방향으로 진행
5. 도착지점 도달 시 경과시간 출력하고 종료

```
q.add(new int[] {0, 0, 0});		// r, c, 벽 부순 여부
```

```
private static void bfs() {
		while(!q.isEmpty()) {
			int[] cur = q.poll();		// 현재 위치
			
			// 사방탐색 진행
			for (int i = 0; i < 4; i++) {
				int nr = cur[0] + rv[i];
				int nc = cur[1] + cv[i];
				
				if(nr < 0 || nr > N-1 || nc < 0 || nc > M-1) continue;
				
				// 벽이라면
				if(map[nr][nc] == 1) {
					if(cur[2] == 0 && !visited[1][nr][nc]) {	// 아직 벽을 부순 적이 없고, 해당 벽이 부숴진 적이 없다면
						visited[cur[2]][nr][nc] = true;		// 해당 벽 부수기
						dist[nr][nc] = dist[cur[0]][cur[1]] + 1;	// 현재 거리 + 1
						q.add(new int[] {nr, nc, 1}); 	// 벽 부순 내용까지 bfs에 담기
					}
					continue;
				}
				
				// 벽이 아니라면
				// 해당 칸을 방문한 적이 없다면
				if(!visited[cur[2]][nr][nc]) {
					visited[cur[2]][nr][nc] = true;		// 방문 처리
					dist[nr][nc] = dist[cur[0]][cur[1]] + 1;	// 현재 거리 + 1
					q.add(new int[] {nr, nc, cur[2]});		// 큐에 넣고 bfs
				}
				
				// 도착지점에 도달하면 경과시간 출력하고 종료
				if(nr == N-1 && nc == M-1) {
					System.out.println(dist[nr][nc] + 1);
					System.exit(0);
				}
			}
		}
	}
```

***

### 주의점
모든 벽에 대해 부수고 지나갈 경우를 전부 실행하여 백트래킹으로 풀이 시 너무 오랜 시간이 걸리기 때문에 BFS로 풀어야 한다.

일반적인 BFS의 경우 목적지에 먼저 도달했을 경우 최단시간이라 볼 수 있지만 벽을 부수고 지나갈 경우 오히려 벽을 부수지 않고 지난간 경우보다 느렸을 수 있다.

따라서 벽을 부쉈을 경우와 부수지 않았을 경우를 나누어 체크할 수 있도록 방문 체크 배열을 3중으로 만들어 사용하는 것이 핵심이다.