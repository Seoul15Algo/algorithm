## 백준 1949 - 우수 마을

***

### 구현 목표
트리 구조로 이루어진 N개의 마을이 주어졌을 때, 다음의 조건을 만족시키면서 우수 마을을 선정해야 한다.

1. 우수 마을로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.
2. 우수 마을끼리는 서로 인접해 있을 수 없다.
3. 우수 마을로 선정되지 못한 마을은 적어도 하나의 우수 마을과는 인접해 있어야 한다.

***

### 풀이 방식

예전에 풀었던 [2533_사회망 서비스](https://www.acmicpc.net/problem/2533)와 유사한 문제다. 단순히 우수 마을로 선정된 개수를 최대화하는 것이 아니라, 우수 마을의 주민의 수를 최대로 만들어야 한다는 점 때문에 두 문제를 다르게 접근해야한다고 생각했지만 결국은 같은 성질의 문제였다.

1. 이번 마을이 우수 마을이라면 다음 마을은 무조건 우수 마을이 아니다.
- 따라서 이번 마을이 우수 마을일때의 dp값은 현재 dp값+다음 마을이 우수 마을이 아닌 경우의 dp값이다.
2. 이번 마을이 우수 마을이 아니라면 다음 마을은 우수 마을일수도, 아닐 수도 있다.
- 따라서 이번 마을이 우수 마을이 아닐 때의 dp값은 다음 마을이 우수 마을일 경우와 그렇지 않은 경우 중 큰 값을 더해준 값이다.
3. 위의 규칙을 적용하여 dfs를 통해 dp테이블을 채워준다.

``` Java
public static void dfs(int n) {
		visited[n] = true;	// 방문 처리
		
		for (int i = 0; i < town[n].size(); i++) {
			int next = town[n].get(i);
			if(visited[next]) continue;		// 이미 방문한 곳은 스킵
			
			dfs(next);
			visited[next] = false;		// 방문 초기화
			
			// 이번 마을이 우수 마을이 아니라면 -> 다음 마을은 우수마을이어도 되고 아니어도 된다
			dp[n][0] += Math.max(dp[next][0], dp[next][1]);
			// 이번 마을이 우수 마을이라면 다음 마을은 무조건 우수 마을이 아니다
			dp[n][1] += dp[next][0];
		}
		
		// 이번 마을이 우수 마을이면 이번 마을의 인구를 더해준다
		dp[n][1] += population[n];
	}
```

진입 노드를 S라고 한다면 결과값은 dp[S][0]과 sp[S][1]중 더 큰 값이 된다.
