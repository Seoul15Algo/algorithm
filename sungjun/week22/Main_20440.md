# 백준 20440 - 🎵니가 싫어 싫어 너무 싫어 싫어 오지 마 내게 찝쩍대지마🎵 - 1

---

## 구현 목표

모기를 싫어하는 지동이는 어느 날 문득 자신의 방에 모기가 가장 많이 있는 시간대가 언제인지 궁금해졌다. 다행히 지동이 방은 최첨단 시스템이 갖춰져 있어 어떤 모기가 방에 언제 입장했고 언제 퇴장했는지를 기록할 수 있다.

지동이를 도와 모기들의 방 입장, 퇴장 시각이 주어졌을 때 모기들이 가장 많이 있는 시간대와 해당 시간대에 모기가 몇 마리가 있는지 구하는 프로그램을 만들어보자.

---

## 풀이 방식

1. 모기를 입장 시각이 빠른 순서로 정렬한다. 
2. 입장 시각이 같다면 퇴장 시각이 빠른 순서로 정렬한다. 
3. 정렬된 모기를 퇴장시간을 기준으로 하는 우선순위 큐에 집어넣는다. 
4. 현재 모기의 입장시간이 우선순위 큐의 가장 앞에 있는 모기의 퇴장시간보다 늦다면 큐의 모기는 퇴장해있는 상태여야 하기 때문에 큐에서 뽑아준다. 
5. 현재 모기의 입장시간이 우선순위 큐의 가장 앞에 있는 모기의 퇴장시간과 같고, 이 값이 최대 모기 존재 구간의 끝 지점과 같다면 끝 지점을 갱신해준다.
6. 큐의 크기를 체크하면서 최대값이 갱신되는 지점에서 시작 시각과 종료 시각을 같이 갱신해준다


``` Java
for (int i = 0; i < N; i++) {
    // 현재 모기의 입장 시간이 이전 모기의 퇴장시간보다 이후라면
    // 이전 모기는 퇴장한 상태이기 때문에 큐에서 뽑아주고 카운트 감소
    while(!pq.isEmpty() && pq.peek() < mos[i].start) {
        pq.poll();
        count--;
    }

    // 현재 모기의 입장 시간이 이전 모기의 퇴장시간과 같다면
    // 만약 이전 모기의 퇴장시간이 최대 모기 포함 구간의 끝과 같다면 끝 지점을 갱신
    // ex) [12, 16] 모기를 포함하는 구간 8~16이 모기 3마리로 현재까지 최대치인 상황에서
    // [16, 19] 모기가 새로 입장했다면 모기 개수는 그대로이지만 구간이 8~19로 갱신됨
    // 아래에서는 같은 마리수일때는 빠른 시작 시간을 보장하기 위해서 최대값이 갱신되는 경우에만 시작 시각과 종료 시각을 갱신하기 때문에 최대 모기 수가 변하지 않는 경우에는 이렇게 따로 갱신을 해줘야 한다
    if(!pq.isEmpty() && pq.peek() == mos[i].start) {
        if(pq.peek() == resultEnd) {
            resultEnd = mos[i].end;
        }

        pq.poll();
        count--;
    }

    // 현재 모기의 퇴장 시간 큐에 넣고 카운트 증가
    pq.add(mos[i].end);
    count++;

    // 최대 마리수 갱신 시 시작 시각과 종료 시각 같이 갱신
    if(count > resultCount) {
        resultCount = count;
        resultStart = mos[i].start;
        resultEnd = pq.peek();
    }
}
```

---
