# 백준_14503_로봇청소기
***

## 1. 문제 조건

N X M 직사각형 형태 (3 <= N, M <= 50)

d -> 0 : 북쪽, 1 : 동쪽, 2 : 남쪽, 3 : 서쪽

테두리는 모두 벽이다.

- 로봇의 작동 방식

> 1. 현재 위치를 청소한다.
> 2. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
>   1. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
>   2. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
>   3. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
>   4. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
***

## 2. 구현 목표

문제의 조건에 맞춰서 로봇이 청소를 할 때 로봇 청소기가 청소할 수 있는 칸의 개수를 구해야 한다.

***

## 3. 아이디어

로봇이 동작하는 방식을 DFS 알고리즘의 기본 형태에 응용하여 문제를 해결했습니다.

4방향 배열을 북, 동, 남, 서 방향으로 우선순위를 설정하고 현재 바라보고 있는 방향을 고려하여 주변을 탐색하고 문제에 조건에 따라 더 이상 탐색할 수 없을 경우 결과를 출력합니다.

```
static void move(int r, int c, int d){
    if(!visit[r][c]) {
        answer++;
        visit[r][c] = true;
    }

    for(int i = 1; i <= 4; i++){
        int nd = (d + 4 - i) % 4;
        int nr = r + dx[nd];
        int nc = c + dy[nd];

        if(arr[nr][nc] == 1 || visit[nr][nc] ){
            continue;
        }
        move(nr, nc, nd);
        return;
    }

    int nr = r + dx[(d + 2) % 4];
    int nc = c + dy[(d + 2) % 4];
    if(arr[nr][nc] == 1){
        return;
    }
    move(nr, nc, d);
}
```



***

## 4. 사용한 알고리즘

DFS를 이용한 구현

***

## 5. 문제를 풀면서 느낀 점

재귀 함수의 경우 자기 자신을 호출 한 이후 호출된 함수가 종료되면 함수를 호출한 위치로 돌아오게 되는데
반환형을 설정한 뒤 return 값으로 함수를 호출하게 되면 호출문으로 돌아오지 않고 종료할 수 있기 때문에 실행 시간을 줄일 수 있다.
이 문제의 경우 해당 방법으로 풀이가 가능한 문제였고 같은 알고리즘을 사용하였지만 반환형이 없는 코드의 경우 136ms, 반환형이 있는 코드의 경우 84ms로 40% 정도의 성능을 개선할 수 있었습니다.