# 백준_3687_성냥개비


## 1. 문제 조건

![성냥](/img/성냥.jpg "성냥")
위의 사진처럼 성냥개비를 이용해서 숫자를 만들 수 있다.\
성냥개비의 개수가 주어지면 해당 성냥개비를 모두 사용해서 숫자를 만들어야하고 숫자는 0으로 시작할 수 없다.

## 2. 구현 목표

성냥개비의 개수가 주어졌을 때, 성냥개비를 모두 사용해서 만들 수 있는 가장 작은 수와 큰 수를 찾는 프로그램을 작성하시오.

## 3. 아이디어

# 가장 큰 숫자
가장 큰 숫자를 만들기 위해서는 수의 자릿 수보다 숫자의 길이를 우선적으로 생각해야 하므로 가장 적은 개수의 성냥개비를 사용하는 숫자로 수를 구성해야한다.\
가장 적은 개수의 성냥개비를 사용하는 숫자는 1로 2개의 성냥을 사용한다.\
이때 전체 성냥의 개수가 홀수라면 모든 성냥을 사용할 수 없으므로 성냥을 3개 사용하는 7을 만들고 나머지 성냥으로는 1을 만든다.
가장 큰 숫자여야하므로 맨 앞의 수를 7로 나머지 1을 뒤에 이어붙혀 숫자를 만든다.

# 가장 작은 숫자
처음에는 dfs를 이용해서 가장 작은 경우를 만들었는데 성냥개비가 100개 주어질 경우 가장 작은 수가 15자리가 되기 때문에 시간초과가 발생했다.\
따라서 DP를 이용해서 기존에 만들었던 결과를 이용해서 문제를 해결했다.

가장 큰 숫자에서 고려했던 것 처럼 숫자의 길이가 숫자의 크기에 가장 큰 영향을 주기 때문에 최대한 짧은 길이의 숫자를 만들어야한다.\
한자리 수를 만들 때 가장 많은 개수의 성냥을 사용하는 경우는 숫자 8로 7개의 성냥을 사용한다. 그렇기 때문에 아래와 같은 중간 결과를 알 수 있다.

| 성냥의 개수  | 숫자의 길이 |
|:-------:|:------:|
|  2 ~ 7  |   1    |
| 8 ~ 14  |   2    |
| 15 ~ 21 |   3    |
| 22 ~ 28 |   4    |
|   ...   |  ...   |


따라서 가장 작은 숫자의 길이가 바뀌는 순간은 성냥의 개수가 7의 배수가 되는 순간이고 한 행의 길이가 7인 2차원 배열을 이용해 dp배열을 구현할 수 있다\
이후 하나의 숫자의 dp값을 구하기 위해서는 길이가 1 짧은 수에 뒤에 숫자 한개를 붙히는 방법들의 최솟값으로 채울 수 있다.

ex) 15개를 이용해 3자리 최솟값을 구하는 경우 : dp[8] + 7, dp[9] + 6, ... , dp[13] + 2 중 최솟값
- DP 값 초기화(1자리 숫자)
```java
for(int i = 0; i < N; i++){
    Arrays.fill(dp[i], INF);
}

dp[0][1] = 1;
dp[0][2] = 7;
dp[0][3] = 4;
dp[0][4] = 2;
dp[0][5] = 6;
dp[0][6] = 8;
```

- DP 계산
```java
for(int i = 1; i < N; i++){
    for(int j = 0; j < M; j++){
        for(int k = 0; k < M - j; k++){
            dp[i][j] = Math.min(dp[i][j], dp[i - 1][j + k] * 10 + tail[M - k - 1]);
        }
    }
}
```

- 가장 큰 숫자
```java
if(now % 2 > 0){
    sb.append(7);
    now -= 3;
}
while(now > 0){
    sb.append(1);
    now -= 2;
}
```

## 4. 사용한 알고리즘

DP