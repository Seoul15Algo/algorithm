# 백준_2206_벽 부수고 이동하기


## 1. 문제 조건

N X M 직사각형 형태 (1 <= N, M <= 1000)

0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽을 나타낸다.

이동하는 과정 중 한 번만 벽을 부수고 지나갈 수 있다.

## 2. 구현 목표

최대 벽을 1번만 부수고 (1, 1) -> (N, M) 까지의 최단경로 탐색


## 3. 아이디어

최단 경로 문제이기 때문에 BFS 알고리즘을 사용하여 문제를 해결하려고 했습니다
> now 배열
>
> now[0] : 현재 위치의 행\
> now[1] : 현재 위치의 열\
> now[2] : 이동해온 경로에서 벽을 부순 횟수\
> now[3] : 현재까지 이동해 온 거리

visit 배열을 boolean이 아닌 int형으로 선언하여 해당 칸에 방문한 결과를 세부적으로 저장할 수 있도록 하였습니다.
> visit 배열
> 
> 0 : 해당 칸에 도착한 적이 없음\
> 1 : 벽을 부수지 않고 해당 칸에 도착한 적이 있음\
> 2 : 벽을 부수고 해당 칸에 도착한 적이 있음\
> 3 : 2가지 방법으로 해당 칸에 도착한 적이 있음 (visit - true)

- BFS 로직
```
 if(arr[nr][nc] == 1 && now[2] == 0){
     q.offer(new int[] {nr, nc, 1, nd});
     visit[nr][nc] = 2;
     continue;
 }
 if(arr[nr][nc] == 0 && now[2] == 0){
     if(visit[nr][nc] % 2 == 0){
         q.offer(new int[] {nr, nc, 0, nd});
         visit[nr][nc]++;
         continue;
     }
 }
 if(arr[nr][nc] == 0 && now[2] == 1){
     if(visit[nr][nc] < 2){
         q.offer(new int[] {nr, nc, 1, nd});
         visit[nr][nc] += 2;
     }
 }
```







## 4. 사용한 알고리즘

BFS를 이용한 구현