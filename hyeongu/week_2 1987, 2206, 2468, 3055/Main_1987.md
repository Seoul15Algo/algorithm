# 백준_1987_알파벳


## 1. 문제 조건

R X C 직사각형 형태 (1 <= R, C<= 20)

각각의 칸에는 대문자 알파벳이 하나씩 적혀있고 말은 항상 (1, 1)에서 출발한다.\
말은 인접한 칸으로 이동할 수 있고 지금까지 지나온 칸에 있는 알파벳과 겹치지 않아야한다.

## 2. 구현 목표

문제의 조건에 맞는 경로 중에서 가장 많은 칸을 지날 수 있는 경로를 찾고 그때 칸 수를 출력하라.


## 3. 아이디어

boolean배열을 이용하여 지나온 칸의 알파벳을 저장하고 DFS 알고리즘을 이용하여 중복되는 알파벳이 나올 때 까지 이동한다.\
이때 알파벳을 boolean배열의 인덱스로 이용하기 위해서 각각의 알파벳을 int형으로 변환해서 사용하였다.

- 알파벳 -> int
```
...
char c = str.charAt(j);
arr[i][j] = c - 'A';        // A -> 0 ~ Z -> 25
...
number[arr[nr][nc]] = true; // 지나온 칸의 알파벳
visit[nr][nc] = true;       // 지나온 칸 visit
...
```

## 4. 사용한 알고리즘

DFS를 이용한 구현
