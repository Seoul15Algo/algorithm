# 백준_1507_궁금한민호


## 1. 문제 조건

도시의 개수와 각 도시에서 다른 도시로 이동할 때 걸리는 시간이 주어진다.\
실제로 존재하는 도로의 시간의 합을 출력하고 불가능할 경우 -1을 출력.

## 2. 구현 목표

처음 주어진 맵은 서로 연결 된 도로가 없어도 경유해서 이동하는 시간이 포함되어있다.\
따라서 모든 이동시간을 MAX값으로 바꾸고, 가장 시간이 짧은 도로부터 지도에 추가하면서 가중치를 갱신한다.
## 3. 아이디어

# 플로이드-워셜
원래는 플로이드-워셜을 사용해야 하는데 문제 풀 때 생각이 안나서 맘대로 풀었습니다.\
근데 풀고보니까 비슷해요

# 도시마다 연결된 도로를 저장
플로이드-워셜은 3중 for문을 이용하여 매번 가중치를 갱신하는 방법으로 진행되는데\
아래와 같은 방법으로 각 도시마다 연결된 도로를 리스트에 저장하고\
새로 방문한 도시에서 기존에 연결된 도로를 재 방문하면서 가중치를 갱신하는 방법으로 진행

- 도로 가중치 갱신
```java
// 새로 추가된 도로를 통해 움직일 수 있는 도시의 이동 시간을 갱신
// a 와 연결된 새로운 도시
for(int next : lists[now.a]){
    map[now.b][next] = Math.min(map[now.b][next], map[now.a][next] + now.cost);
    map[next][now.b] = map[now.b][next];
}

// b 와 연결된 새로운 도시
for(int next : lists[now.b]){
    map[now.a][next] = Math.min(map[now.a][next], map[now.b][next] + now.cost);
    map[next][now.a] = map[now.a][next];
}

// 새로 이어진 도로를 추가
lists[now.a].add(now.b);
lists[now.b].add(now.a);
```

- -1인 경우
```
if(map[now.a][now.b] < now.cost)
    문제에서 주어진 도로보다 더 짧은 도로가 완성된 경우 -> -1
    
if(map[now.a][now.b] == now.cost)
    문제에서 주어진 도로와 같은 가중치의 도로가 이미 완성되어있는 경우
    
if(map[now.a][now.b] > now.cost)
    아직 도로가 완성되지 않은경우
```

## 4. 사용한 알고리즘

그래프