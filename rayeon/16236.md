# # 16236 아기 상어
## 문제
- 아기 상어가 몇 초 동안 물고기를 잡아먹을 수 있는지 구하기
- N X N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 존재한다.
- 아기 상어의 초기 크기는 2이고, 1초마다 상하좌우로 인접한 한 칸씩 이동 가능
	* 자신의 크기보다 큰 물고기가 있는 칸은 이동 불가
	* 자신의 크기와 같은 물고기가 있는 칸은 이동 가능
	* 자신의 크기보다 작은 물고기가 있는 칸은 이동 및 식사 가능
- 아기 상어가 이동할 위치 결정 방법
	* 더 이상 먹을 수 있는 물고기가 없다면 중지
	* 거리가 가장 가까운 물고기를 먹으러 간다.
		* 거리가 동일한 물고기가 많은 경우, 왼쪽 상단에 위치한 물고기를 먹는다.
- 아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때마다 크기 증가

&nbsp;

---
## 풀이
## 1. void bfs(int x, int y) {}
#####  *현재 아기 상어와 아기 상어가 먹을 수 있는 물고기들 간 거리를 계산하는 메서드*

&nbsp;

```java
        d = new int[N][N];
		for (int i = 0; i < N; i++)
			Arrays.fill(d[i], -1);
```
- 아기 상어와 물고기들 간 거리를 담는 배열 d를 -1로 초기화한다. -1은 아기 상어가 갈 수 없음을 의미한다.

&nbsp;

```java
        Queue<Node> q = new LinkedList<Node>();
		q.offer(new Node(x,y,0));
		d[x][y] = 0;
```
- 현재 위치를 기준으로 상, 하, 좌, 우에 인접한 노드를 저장할 큐 생성
- 현재 아기 상어 위치를 큐에 추가하고, 거리를 담는 배열 d에 자기 자신과의 거리인 0을 넣는다.

&nbsp;

```java
    if(d[nx][ny] == -1 && g[nx][ny] <= size) {
        if(g[nx][ny] == 0 || g[nx][ny] == size)
            d[nx][ny] = -2;
        else if(g[nx][ny] < size)
            d[nx][ny] = node.dist+1;
        
        q.offer(new Node(nx,ny,node.dist+1));
    }
```
- 한 번도 방문하지 않고(d == -1), 자신보다 크기가 작은 인접 노드 중 물고기가 없거나 아기 상어와 동일한 크기의 물고기가 있는 경우, 먹진 못하나 지나갈 순 있으므로 d 배열에 -2를 넣어 방문 처리한다.
- 만약 아기 상어의 크기보다 인접 노드에 있는 물고기 크기가 더 작다면 d 배열에 아기 상어와 해당 물고기 간 거리 값을 넣는다.

&nbsp;

## 2. Node shortestFist(int x, int y) {}
#####  *아기 상어가 먹을 수 있는 물고기들 중 가장 가까운 물고기 위치를 반환하는 메서드*

&nbsp;

```java
    int min_distance = Integer.MAX_VALUE;
		int minX = -1;
		int minY = -1;
		
		for(int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				if(d[i][j] <= 0)
					continue;
				
				if(d[i][j] < min_distance) {
					minX = i;
					minY = j;
					min_distance = d[i][j];
				}
			}
		}
```
- d 값이 양수일 때만 아기 상어가 해당 위치의 물고기를 잡아 먹을 수 있다. 
- 그 중 제일 가까운 물고기의 위치를 알아낼 수 있도록 값을 비교한 뒤 해당 위치(minX, min Y)를 리턴한다.
- 먹을 수 있는 물고기가 없는 경우 (-1, -1)을 리턴한다.

&nbsp;

## 3. main

&nbsp;

```java
		while(true) {
			Node n = shortestFish(x, y);
			
			if(n.x==-1 && n.y==-1) {
				break;
			}
			
			g[x][y] = 0; // 현재 아기 상어의 위치
			g[n.x][n.y] = 9; // 잡아 먹을 물고기 위치
			
			x = n.x;
			y = n.y;
			result += n.dist; // 물고기를 잡아먹는 총 시간
			cnt++; // 아기 상어가 먹은 물고기 수
			
			if(cnt == size) {
				cnt = 0;
				size++;
			}
		}
```
- 아기 상어가 먹을 수 있는 물고기가 없다면 while 문을 종료한다.
- 먹을 수 있는 물고기가 존재하는 경우 해당 물고기 위치 값을 0으로 변경하고, 아기 상어의 위치를 물고기 위치로 변경하여 이동한다.
- 제일 가까운 위치에 있는 물고기를 잡아 먹을 때마다 시간 증가
- 아기 상어가 먹은 물고기 수가 현재 자신의 크기와 같다면 아기 상어 크기 증가