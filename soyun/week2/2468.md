# ì•ˆì „ì˜ì—­ - ğŸš«

## ë¬¸ì œ ì„¤ëª…

- ì•ˆì „í•œ ì˜ì—­
  - ì•ˆì „í•œ ì˜ì—­ì´ë€, ë¹„ê°€ ë‚´ë¦° ë†’ì´ë³´ë‹¤ í° ë†’ì´ë¥¼ ê°€ì§„ ì˜ì—­ì´ë‹¤.
  - ì¸ì ‘í•œ ëª¨ë“  ì•ˆì „í•œ ì¹¸ì„ í•©í•œ ê²ƒì„ í•˜ë‚˜ì˜ ì•ˆì „í•œ ì˜ì—­ìœ¼ë¡œ ë³¸ë‹¤.
- ë¹„ì˜ ì–‘ì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” ì•ˆì „í•œ ì˜ì—­ì˜ ìµœëŒ€ ê°œìˆ˜ë¥¼ êµ¬í•˜ë¼.


## ë¬¸ì œ í’€ì´
1. ê±´ë¬¼ ë†’ì´ì˜ min, maxë¥¼ êµ¬í•œë‹¤ -> ë°˜ë³µë¬¸ì„ ëœ ëŒë¦¬ê¸° ìœ„í•¨
2. **(min - 1)** (ëª¨ë“  ê±´ë¬¼ì´ ì ê¸°ì§€ ì•Šì„ ê²½ìš°)ë¶€í„° **(max)**(ëª¨ë“  ê±´ë¬¼ì´ ì ê¸°ëŠ” ê²½ìš°)ê¹Œì§€ ë°˜ë³µ
   - ì ê¸°ì§€ ì•Šì€ êµ¬ì—­ í•œ ì¹¸ í•œ ì¹¸ì„ ëŒë©´ì„œ BFS ì‹¤í–‰ -> ì•ˆì „í•œ ì˜ì—­ì˜ ê°œìˆ˜ë¥¼ ì„¼ë‹¤.
   - ê¸°ì¡´ì˜ ì•ˆì „ ì˜ì—­ ê°œìˆ˜ ìµœëŒ“ê°’ê³¼ ë¹„êµí•˜ì—¬ ê°±ì‹ í•œë‹¤.
3. ì•ˆì „í•œ ì˜ì—­ ê°œìˆ˜ì˜ ìµœëŒ“ê°’ì„ ì¶œë ¥
  ```java
  
      public static void main(String[] args) throws Exception {
  
          BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
          n = Integer.parseInt(br.readLine());
          area = new int[n][n];
  
          int min = Integer.MAX_VALUE;
          int max = Integer.MIN_VALUE;
          for (int i = 0; i < n; i++) {
              StringTokenizer st = new StringTokenizer(br.readLine());
              for (int j = 0; j < n; j++) {
                  area[i][j] = Integer.parseInt(st.nextToken());
                  min = Math.min(min, area[i][j]);
                  max = Math.max(max, area[i][j]);
              }
          }
  
          int result = Integer.MIN_VALUE;
          int cnt;
          for (int k = min - 1; k < max; k++) {
              cnt = 0;
              check = new boolean[n][n];
              for (int i = 0; i < n; i++) {
                  for (int j = 0; j < n; j++) {
                      if (!check[i][j] && area[i][j] > k) {
                          bfs(i, j, k);
                          cnt++;
                      }
                  }
              }
              result = Math.max(result, cnt);
          }
          System.out.println(result);
      }
  
      static void bfs(int r, int c, int depth) {
  
          Queue<int[]> q = new LinkedList<>();
          q.offer(new int[]{r, c});
          while(!q.isEmpty()) {
              int[] cur = q.poll();
              for (int i = 0; i < 4; i++) {
                  int nx = cur[0] + dx[i];
                  int ny = cur[1] + dy[i];
                  if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
                  if (check[nx][ny] || area[nx][ny] <= depth) continue;
                  q.offer(new int[] {nx, ny});
                  check[nx][ny] = true;
              }
          }
      }
  }
  ```
  
